//! The Forge: Self-Synthesis Skill (Code Generator).
//!
//! Takes a JSON tool-spec from the LLM, generates a new `.rs` file in the skills
//! directory, appends the module to lib.rs, and runs `cargo check` to ensure the
//! new tool doesn't break the build. "If the skill doesn't exist, we build it."

use pagi_core::{AgentSkill, TenantContext};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use std::process::Command;

const SKILL_NAME: &str = "forge";

/// JSON tool-spec from the LLM for generating a new skill.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolSpec {
    /// Skill name (snake_case). Used for module name and file name.
    pub name: String,
    /// Human-readable description (for the skill's description() and doc comment).
    #[serde(default)]
    pub description: String,
    /// Optional list of parameter names (for the generated execute() signature / payload).
    #[serde(default)]
    pub params: Vec<ToolSpecParam>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolSpecParam {
    pub name: String,
    #[serde(rename = "type")]
    pub param_type: String,
    #[serde(default)]
    pub required: bool,
}

/// Result of a Forge create operation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForgeResult {
    pub success: bool,
    pub module_name: String,
    pub file_path: String,
    pub cargo_check_ok: bool,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cargo_stderr: Option<String>,
}

/// Validates that `name` is a safe Rust module name (snake_case, no path traversal).
fn sanitize_module_name(name: &str) -> Result<String, String> {
    let s = name.trim();
    if s.is_empty() {
        return Err("Skill name cannot be empty".to_string());
    }
    if s.contains("..") || s.contains('/') || s.contains('\\') {
        return Err("Skill name may not contain path components".to_string());
    }
    let safe: String = s
        .chars()
        .map(|c| if c.is_ascii_alphanumeric() || c == '_' { c } else { '_' })
        .collect();
    if safe != s {
        return Err(format!(
            "Skill name must be snake_case alphanumeric + underscore, got: {}",
            name
        ));
    }
    if safe.starts_with('_') || safe.ends_with('_') {
        return Err("Skill name must not start or end with underscore".to_string());
    }
    Ok(safe.to_string())
}

/// Generate Rust source for a minimal AgentSkill module from a tool spec.
fn generate_skill_rs(spec: &ToolSpec) -> String {
    let name = &spec.name;
    let desc = spec.description.replace("\\", "\\\\").replace('"', "\\\"");
    let mod_doc = if desc.is_empty() {
        format!("! Auto-generated skill: {}.", name)
    } else {
        format!("! {}", desc)
    };

    let params_parsing: String = spec
        .params
        .iter()
        .map(|p| {
            let key = &p.name;
            let var = format!("p_{}", key.replace('-', "_"));
            let optional = !p.required;
            if optional {
                format!(
                    "        let {} = payload.get(\"{}\").cloned();",
                    var, key
                )
            } else {
                format!(
                    "        let {} = payload.get(\"{}\").ok_or(\"Missing '{}'\")?.clone();",
                    var, key, key
                )
            }
        })
        .collect::<Vec<_>>()
        .join("\n");

    let result_fields: String = spec
        .params
        .iter()
        .map(|p| {
            let var = format!("p_{}", p.name.replace('-', "_"));
            format!("            \"{}\": {},", p.name, var)
        })
        .collect::<Vec<_>>()
        .join("\n");

    format!(
        r#"//! {}
//! Generated by The Forge. Do not edit by hand without re-running cargo check.

use pagi_core::{{AgentSkill, TenantContext}};

const SKILL_NAME: &str = "{}";

pub struct {};

impl {} {{
    pub fn new() -> Self {{
        Self {{}}
    }}
}}

#[async_trait::async_trait]
impl AgentSkill for {} {{
    fn name(&self) -> &str {{
        SKILL_NAME
    }}

    async fn execute(
        &self,
        _ctx: &TenantContext,
        payload: Option<serde_json::Value>,
    ) -> Result<serde_json::Value, Box<dyn std::error::Error + Send + Sync>> {{
        let payload = payload.ok_or("{} requires a payload")?.as_object().ok_or("payload must be object")?;
{}
        Ok(serde_json::json!({{
            "status": "ok",
            "skill": SKILL_NAME,
{}
        }}))
    }}
}}
"#,
        mod_doc,
        name,
        pascal_case(name),
        pascal_case(name),
        pascal_case(name),
        name,
        params_parsing,
        result_fields
    )
}

fn pascal_case(s: &str) -> String {
    s.split('_')
        .map(|w| {
            let mut c = w.chars();
            match c.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().chain(c).collect(),
            }
        })
        .collect()
}

/// Writes the new module file and appends `mod X;` to lib.rs, then runs `cargo check`.
/// `skills_src_dir` = path to `crates/pagi-skills/src`, `workspace_root` = repo root for cargo.
pub fn create_skill_from_spec(
    spec: &ToolSpec,
    skills_src_dir: &Path,
    workspace_root: &Path,
) -> Result<ForgeResult, String> {
    let module_name = sanitize_module_name(&spec.name)?;
    let file_name = format!("forge_gen_{}.rs", module_name);
    let file_path = skills_src_dir.join(&file_name);
    let lib_rs = skills_src_dir.join("lib.rs");

    let code = generate_skill_rs(spec);
    std::fs::write(&file_path, &code).map_err(|e| format!("Failed to write {}: {}", file_path.display(), e))?;

    let mod_line = format!("mod forge_gen_{};", module_name);
    let lib_content = std::fs::read_to_string(&lib_rs).map_err(|e| format!("Failed to read lib.rs: {}", e))?;
    if lib_content.contains(&mod_line) {
        // Already registered
    } else {
        let insert_after = "mod deep_audit;";
        let new_lib = if let Some(pos) = lib_content.find(insert_after) {
            let end = pos + insert_after.len();
            format!(
                "{}\n{}\n{}",
                &lib_content[..end],
                mod_line,
                &lib_content[end..]
            )
        } else {
            format!("{}\n{}\n", lib_content.trim_end(), mod_line)
        };
        std::fs::write(&lib_rs, new_lib).map_err(|e| format!("Failed to update lib.rs: {}", e))?;
    }

    let cargo_check = Command::new("cargo")
        .arg("check")
        .arg("-p")
        .arg("pagi-skills")
        .current_dir(workspace_root)
        .output();

    let (cargo_check_ok, cargo_stderr) = match cargo_check {
        Ok(out) => {
            let ok = out.status.success();
            let stderr = if out.stderr.is_empty() {
                None
            } else {
                Some(String::from_utf8_lossy(&out.stderr).to_string())
            };
            (ok, stderr)
        }
        Err(e) => (false, Some(format!("cargo check failed to run: {}", e))),
    };

    let message = if cargo_check_ok {
        format!(
            "Forge created skill '{}'. Module: forge_gen_{}. Rebuild gateway to load.",
            spec.name, module_name
        )
    } else {
        format!(
            "Forge wrote {} but cargo check failed. Fix errors and run cargo check -p pagi-skills.",
            file_path.display()
        )
    };

    Ok(ForgeResult {
        success: cargo_check_ok,
        module_name: format!("forge_gen_{}", module_name),
        file_path: file_path.to_string_lossy().to_string(),
        cargo_check_ok,
        message,
        cargo_stderr,
    })
}

/// AgentSkill wrapper for The Forge (invokable by the orchestrator).
pub struct ForgeSkill;

impl ForgeSkill {
    pub fn new() -> Self {
        Self {}
    }
}

impl Default for ForgeSkill {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait::async_trait]
impl AgentSkill for ForgeSkill {
    fn name(&self) -> &str {
        SKILL_NAME
    }

    async fn execute(
        &self,
        _ctx: &TenantContext,
        payload: Option<serde_json::Value>,
    ) -> Result<serde_json::Value, Box<dyn std::error::Error + Send + Sync>> {
        let payload = payload.ok_or("forge requires payload: { name, description?, params? }")?;
        let spec: ToolSpec = serde_json::from_value(payload).map_err(|e| format!("Invalid tool spec: {}", e))?;

        let workspace_root = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
        let skills_src = workspace_root.join("crates/pagi-skills/src");

        if !skills_src.join("lib.rs").exists() {
            return Err("crates/pagi-skills/src not found (run from workspace root)".into());
        }

        let result = create_skill_from_spec(&spec, &skills_src, &workspace_root)
            .map_err(|e| format!("Forge error: {}", e))?;

        Ok(serde_json::to_value(result)?)
    }
}
